除了暴力的解法，感觉就是找到无重复字符最长子串的规律即可。

本题只需遍历一次字符串即可找到无重复最长子串。

1. 两个相同字符间，且区间内无重复为一段子串。

对于 `abcda` 不管是拆分为 `abcd` 或是 `bcda` 均为合理子串且长度相同。

2. 向后遍历遇到相同字符，不需要抛弃前面所有合法子串

对于 `abcdaefg` ，当我们遍历至 `abcda` 时不需要抛弃前面的 `abcd` 。只需抛弃第一个重复的字符，再继续往后遍历即可。也就是说我们遇到第二个 `a` 时，我们删除第一个 `a` ，继续向后遍历 (`bcda`、`bcdae`、`bcdaef`、`bcdaefg`)。

3. 我们使用 HashMap 来储存当前字符最新一次出现的下标
4. 如果遇到重复字符，需要更新计数起点(如规则 2)。

如规则 2，当我们遍历至 `abcda` 时，我们更新计数起点只要取到 `a` 第一出现的位置并 `+1` 即可

但是仍有一些特殊情况。比如 `abba` ，我们遍历到第二个 `b` 时计数起点更新为 2，但是此时遍历最后一个 `a` 时，如果我们取第一次 `a` 出现下标 `+1` 那么我们就破坏了原来正常的计数起点并让其后退了。所以我们的计数下标应该是一直向后增加的。所以计数下标应该取 `当前下标` 和 `重复字符下标 + 1` 较大的值。
